[
  {
    "title": "Python Grundlæggende og Syntax",
    "content": "Python er et højniveau programmeringssprog skabt af Guido van Rossum i 1991. Det er kendt for sin enkle og læsbare syntax der minder om naturligt sprog. Python bruger indrykning til at definere kodeblokke i stedet for krøllede parenteser. Sproget understøtter flere programmeringsparadigmer inklusiv objektorienteret, funktionel og procedural programmering. Python har en omfattende standardbibliotek der dækker alt fra filhåndtering til netværkskommunikation. Variable i Python er dynamisk typede, hvilket betyder at du ikke behøver at deklarere typen eksplicit. Python har indbyggede datatyper som strings, integers, floats, lists, tuples, dictionaries og sets. Funktioner defineres med def keyword og kan tage både positionelle og keyword argumenter. Python understøtter også list comprehensions der giver en kortfattet måde at skabe lister på. Error handling gøres med try-except blokke der fanger exceptions. Python 3 er den nuværende version og har væsentlige forbedringer over Python 2 inklusiv bedre Unicode support og print som funktion.",
    "source": "Python Official Documentation 3.11, Introduction to Python"
  },
  {
    "title": "FastAPI Framework og Moderne API Udvikling",
    "content": "FastAPI er et moderne, hurtigt web framework til at bygge APIs med Python baseret på standard Python type hints. Det blev skabt af Sebastián Ramírez og er bygget oven på Starlette for web delen og Pydantic for data delen. FastAPI genererer automatisk OpenAPI dokumentation der kan tilgås via /docs endpoint med Swagger UI eller /redoc for ReDoc interface. Frameworket bruger Python type annotations til automatisk request validering, serialisering og dokumentation. FastAPI understøtter asynkron programmering med async/await syntax hvilket gør det ekstremt performant. Dependency injection systemet i FastAPI gør det nemt at dele logik mellem endpoints og håndtere authentication, database connections og andre afhængigheder. Path parameters defineres direkte i route decorator mens query parameters defineres som funktionsparametre. Request body validering sker automatisk gennem Pydantic models der også bruges til response models. FastAPI har indbygget support for WebSockets, background tasks, CORS middleware og file uploads. Testing af FastAPI applikationer er nemt med TestClient fra starlette.testclient.",
    "source": "FastAPI Official Documentation 0.104, FastAPI Guide by Sebastián Ramírez"
  },
  {
    "title": "ChromaDB Vector Database og Embeddings",
    "content": "ChromaDB er en open-source embedding database designet til at være let at bruge og ikke kræve kompleks opsætning. Den fungerer som en vector database der gemmer og søger i embeddings genereret fra tekst, billeder eller andre data. ChromaDB kan køre in-memory til udvikling eller persistent til produktion ved at specificere en sti. Collections i ChromaDB fungerer som tabeller og kan have associeret metadata for filtrering. Når du tilføjer dokumenter til ChromaDB, kan du enten provide dine egne embeddings eller lade ChromaDB generere dem automatisk ved hjælp af default embedding function. Query operationer bruger cosine similarity eller andre distance metrics til at finde de mest relevante dokumenter. ChromaDB understøtter både exact nearest neighbor search og approximate nearest neighbor search for bedre performance på store datasets. Metadata filtering lader dig kombinere vector search med traditionel filtrering på felter som dato, kategori eller tags. ChromaDB kan bruges med forskellige embedding models inklusiv OpenAI embeddings, Sentence Transformers og custom models. Update og delete operationer understøttes også så du kan modificere eksisterende dokumenter. ChromaDB integrerer godt med LangChain og andre LLM frameworks.",
    "source": "ChromaDB Documentation v0.4.15, Getting Started with Vector Databases"
  },
  {
    "title": "RAG Arkitektur og Implementation",
    "content": "Retrieval-Augmented Generation er en teknik der kombinerer information retrieval med language model generation for at give mere faktuelle og opdaterede svar. RAG løser problemet med at LLMs kun kender til data fra deres træningsperiode og kan hallucinere fakta. Arkitekturen består af tre hovedkomponenter: en vector database med embeddings af dokumenter, en retrieval komponent der finder relevante dokumenter, og en generative komponent der syntetiserer svar baseret på de fundne dokumenter. I praksis fungerer RAG ved først at embedde brugerens query, derefter søge efter lignende embeddings i vector databasen, og endelig give de fundne dokumenter som kontekst til LLM sammen med det originale spørgsmål. Chunk size er kritisk - for små chunks mister kontekst mens for store chunks indeholder irrelevant information. Overlap mellem chunks hjælper med at bevare kontekst på tværs af boundaries. Re-ranking kan forbedre resultaterne ved at sortere de fundne dokumenter efter relevans før de sendes til LLM. Hybrid search kombinerer semantic search med keyword search for bedre precision. RAG kan også bruge query expansion hvor det originale spørgsmål omformuleres på flere måder for at fange flere relevante dokumenter.",
    "source": "Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks, Lewis et al. 2020"
  },
  {
    "title": "Docker Containerization og Best Practices",
    "content": "Docker er en platform til at udvikle, shippe og køre applikationer i containers. Containers pakker applikationen og alle dens dependencies sammen så den kører identisk på tværs af miljøer. En Dockerfile er et script med instruktioner til at bygge et Docker image. FROM instruktionen specificerer base image, RUN udfører kommandoer, COPY kopierer filer ind i image, og CMD definerer default kommando når container startes. Multi-stage builds reducerer image størrelse ved at bruge flere FROM statements og kun kopiere nødvendige artifacts til final image. .dockerignore filen specificerer hvilke filer der ikke skal inkluderes i build context. Docker Compose orkestrer multi-container applikationer ved at definere services, networks og volumes i en docker-compose.yml fil. Volumes bevarer data selv når containers stoppes eller slettes. Networks lader containers kommunikere sikkert med hinanden. Environment variables kan passes til containers via ENV i Dockerfile eller environment i docker-compose. Health checks verificerer at containeren kører korrekt. Docker Hub er et registry til at dele og distribuere images. Best practices inkluderer at bruge officielle base images, minimere antal layers, køre containers som non-root user, og scanne images for sårbarheder.",
    "source": "Docker Documentation, Best Practices for Writing Dockerfiles"
  },
  {
    "title": "REST API Design Principper og Conventions",
    "content": "REST står for Representational State Transfer og er en arkitektonisk stil for at designe networked applications. RESTful APIs bruger HTTP requests til at udføre CRUD operationer: Create via POST, Read via GET, Update via PUT eller PATCH, og Delete via DELETE. URLs i REST repræsenterer ressourcer ikke actions - brug /users ikke /getUsers. Ressourcer bør være navngivet med substantiver i flertal som /products /orders /customers. Nested ressourcer kan repræsenteres hierarkisk som /users/123/orders. Query parameters bruges til filtrering, sortering og pagination som /products?category=electronics&sort=price&page=2. HTTP status codes kommunikerer resultatet: 200 OK for success, 201 Created for nye ressourcer, 400 Bad Request for invalid input, 401 Unauthorized for authentication fejl, 404 Not Found for ikke-eksisterende ressourcer, 500 Internal Server Error for server fejl. Response bodies bør returnere JSON eller XML konsistent. Versioning kan håndteres via URL path /api/v1/users eller via headers. HATEOAS principper inkluderer links til relaterede ressourcer i responses. Idempotency betyder at samme request kan udføres flere gange med samme resultat - GET PUT og DELETE bør være idempotente. Rate limiting beskytter API mod overload. API documentation bør inkludere endpoints, parameters, request/response examples og authentication requirements.",
    "source": "RESTful Web Services, Richardson & Ruby 2007, O'Reilly Media"
  },
  {
    "title": "PostgreSQL Database Administration og Features",
    "content": "PostgreSQL er et kraftfuldt open-source objekt-relationelt database system med over 35 års aktiv udvikling. Det er kendt for sin robusthed, feature set og performance. PostgreSQL understøtter ACID transactions hvilket garanterer data integritet selv ved system fejl. Data types i PostgreSQL inkluderer standard SQL types samt advanced types som JSON, JSONB, arrays, hstore, geometric types og custom types. JSONB er særligt populært da det kombinerer fleksibiliteten af NoSQL med SQL queries. Indexes forbedrer query performance - B-tree er default men PostgreSQL understøtter også hash, GiST, SP-GiST, GIN og BRIN indexes. Full-text search er indbygget med støtte for stemming, ranking og forskellige sprog. Constraints håndhæver data integritet: PRIMARY KEY for unikke identifiers, FOREIGN KEY for relationer, UNIQUE for unikke værdier, CHECK for custom validering. Views er saved queries der kan behandles som virtuelle tabeller. Materialized views cacher query resultater for performance. Triggers er funktioner der automatisk udføres ved events som INSERT UPDATE eller DELETE. Stored procedures og functions kan skrives i PL/pgSQL SQL Python eller andre sprog. Partitioning opdeler store tabeller i mindre stykker for bedre performance. Replication giver high availability ved at kopiere data til andre servere.",
    "source": "PostgreSQL 15 Official Documentation, Chapter 1-5"
  },
  {
    "title": "Git Version Control Workflow og Commands",
    "content": "Git er et distribueret version control system skabt af Linus Torvalds i 2005. Hver udvikler har en fuld kopi af repository historikken lokalt. Et Git repository initialiseres med git init eller clones fra remote med git clone. Working directory indeholder de faktiske filer, staging area holder ændringer klar til commit, og repository indeholder committed historie. git add tilføjer filer til staging area, git commit gemmer ændringer med en besked, git push sender commits til remote repository, git pull henter og merger ændringer fra remote. Branches lader flere udviklere arbejde parallelt uden at påvirke hinanden - git branch lister branches, git checkout -b opretter ny branch. Merging kombinerer ændringer fra forskellige branches med git merge, mens rebase giver en lineær historie. Merge conflicts opstår når samme linjer er ændret i forskellige branches og skal løses manuelt. git status viser working directory status, git log viser commit historie, git diff viser ændringer. Remote repositories som GitHub eller GitLab fungerer som centrale servere til collaboration. Pull requests er en måde at review og diskutere ændringer før de merges. .gitignore specificerer filer Git skal ignorere som node_modules eller .env filer. Tags markerer vigtige points i historien som releases.",
    "source": "Pro Git Book 2nd Edition, Chacon & Straub 2023, Apress"
  },
  {
    "title": "JWT Authentication og Security",
    "content": "JSON Web Token er en kompakt URL-safe måde at repræsentere claims mellem to parter. JWT består af tre dele adskilt af punktummer: header, payload og signature. Header indeholder token type og hashing algoritme typisk HS256 eller RS256. Payload indeholder claims som user ID, expiration time, issuer og custom data. Signature sikrer at token ikke er blevet modificeret og genereres ved at hashe header og payload med en secret key. JWT er stateless hvilket betyder serveren ikke behøver at gemme session information. Efter login genererer serveren et JWT som sendes til klienten typisk i en HTTP header eller cookie. Klienten inkluderer JWT i Authorization header som Bearer token ved efterfølgende requests. Serveren verificerer JWT signature og checker expiration før den tillader adgang til beskyttede ressourcer. Refresh tokens er længere-lived tokens brugt til at få nye access tokens når de udløber. Best practices inkluderer at bruge HTTPS altid, holde expiration times korte, gemme secrets sikkert, validere alle claims, og bruge strong algoritmer. JWT bør ikke indeholde sensitive data da payload er kun base64 encoded ikke encrypted. For højere sikkerhed kan tokens også encrypts med JWE. Revocation af JWT er udfordrende pga stateless nature men kan håndteres med blacklists eller korte expiration times.",
    "source": "RFC 7519 - JSON Web Token (JWT) Standard, IETF"
  },
  {
    "title": "Kubernetes Container Orchestration",
    "content": "Kubernetes er en open-source platform til automating deployment, scaling og management af containerized applications. Det blev oprindeligt udviklet af Google og er nu maintained af Cloud Native Computing Foundation. Kubernetes arkitekturen består af en control plane og worker nodes. Control plane komponenter inkluderer API server som frontend, etcd for distributed key-value storage, scheduler som tildeler pods til nodes, og controller manager. Worker nodes kører kubelet agent, container runtime som Docker eller containerd, og kube-proxy for netværk. Pods er den mindste deployable unit i Kubernetes og kan indeholde en eller flere tæt koblede containers. Deployments håndterer pod lifecycle og rolling updates. Services eksponerer pods til netværket og giver load balancing. ConfigMaps og Secrets gemmer konfiguration og sensitive data adskilt fra application code. Persistent Volumes giver storage til pods der overlever pod restarts. Namespaces giver isolation mellem forskellige teams eller miljøer. Ingress håndterer external HTTP/HTTPS routing til services. Horizontal Pod Autoscaler automatisk scaler pod antal baseret på CPU eller custom metrics. Labels og selectors bruges til at organisere og vælge resources. kubectl er command-line tool til at interagere med clusters.",
    "source": "Kubernetes Documentation v1.28, Kubernetes Concepts"
  },
  {
    "title": "Microservices Architecture Patterns",
    "content": "Microservices arkitektur opdeler applikationer i små uafhængige services der hver håndterer en specifik business capability. Hver microservice har sin egen database og kan deployes uafhængigt hvilket giver høj skalerbarhed og fejltolerance. Services kommunikerer typisk via REST APIs, gRPC eller message queues som RabbitMQ eller Kafka. API Gateway fungerer som single entry point for klienter og håndterer routing, authentication og rate limiting. Service discovery mekanismer som Consul eller Eureka lader services finde hinanden dynamisk. Circuit breaker pattern forhindrer cascade failures ved at afbryde requests til failing services. Eventual consistency accepteres da distribuerede transaktioner er komplekse - Saga pattern koordinerer transaktioner på tværs af services. Hver microservice bør følge single responsibility principle og være loosely coupled. Distributed tracing med tools som Jaeger hjælper med at debugge requests der spænder over multiple services. Centralized logging aggregerer logs fra alle services til lettere monitoring. Container orchestration med Kubernetes er populært til deployment. Challenges inkluderer øget kompleksitet, network latency, data consistency og testing af distribuerede systemer. Best practices inkluderer at definere klare service boundaries, implementere comprehensive monitoring, automatisere deployments og have god documentation.",
    "source": "Building Microservices, 2nd Edition, Sam Newman, O'Reilly 2021"
  },
  {
    "title": "CI/CD Pipeline Implementation",
    "content": "Continuous Integration og Continuous Deployment er practices der automatiserer software delivery processen. CI betyder at developers integrerer kode til shared repository flere gange dagligt hvor hver integration verificeres af automated builds og tests. CD udvider CI til automatisk at deploye alle kode ændringer til production efter at de passer tests. En typisk CI/CD pipeline starter med source control trigger når kode pushes. Build stage compiler kode og resolver dependencies. Test stage kører unit tests, integration tests og end-to-end tests. Code quality checks inkluderer linting, security scanning og code coverage analysis. Artifact creation pakker applikationen i deployable format som Docker image. Deployment stage deployer til forskellige miljøer - ofte først staging derefter production. Rollback mekanismer lader dig hurtigt vende tilbage til previous version ved fejl. Popular CI/CD tools inkluderer Jenkins, GitLab CI, GitHub Actions, CircleCI og Travis CI. Pipeline configuration defineres typisk i YAML filer i repository. Environment variables og secrets manages sikkert gennem CI/CD platform. Monitoring og alerting notificerer teams om pipeline failures. Blue-green deployments og canary releases minimerer risiko ved at route kun en del af traffic til ny version først.",
    "source": "Continuous Delivery, Humble & Farley, Addison-Wesley 2010"
  },
  {
    "title": "SQL Query Optimization Techniques",
    "content": "SQL query optimization er kritisk for database performance især på store datasets. EXPLAIN eller EXPLAIN ANALYZE kommandoer viser query execution plan og hjælper med at identificere bottlenecks. Indexes er det vigtigste optimeringsværktøj - de virker som en bog index og lader databasen hurtigt finde rows uden at scanne hele tabellen. B-tree indexes er default og fungerer godt til equality og range queries. Composite indexes på multiple columns kan optimere queries med WHERE clauses på flere felter men rækkefølgen af columns er vigtig. SELECT statements bør kun hente nødvendige columns ikke SELECT * da dette reducerer I/O. WHERE clauses bør filtrere så tidligt som muligt for at reducere data mængde. JOIN operations kan være dyre - INNER JOIN er typisk hurtigst, mens subqueries ofte kan omskrives til JOINs for bedre performance. Query planner bruger statistics om data distribution til at vælge optimal execution strategy så ANALYZE kommando bør køres regelmæssigt. Pagination med LIMIT og OFFSET er ineffektiv på høje offset values - keyset pagination med WHERE id > last_seen_id er hurtigere. Denormalization kan forbedre read performance ved at reducere JOINs men øger write kompleksitet. Materialized views cacher komplekse query resultater. Query caching på application level reducerer database load.",
    "source": "SQL Performance Explained, Markus Winand, 2012"
  },
  {
    "title": "OAuth 2.0 Authorization Framework",
    "content": "OAuth 2.0 er en authorization framework der lader third-party applications få limited access til HTTP services. Det adskiller authentication fra authorization ved at bruge access tokens i stedet for credentials. OAuth definerer fire roller: resource owner (user), client (application), authorization server (authenticator), og resource server (API). Authorization code flow er mest sikker for web apps: user redirectes til authorization server, logger ind, authorization server redirecter tilbage til client med authorization code, client bytter code til access token. Implicit flow var tidligere brugt til browser-based apps men er nu deprecated til fordel for authorization code flow med PKCE. Client credentials flow bruges til server-to-server communication hvor der ikke er en user involved. Resource owner password flow giver client direkte adgang til user credentials og bør kun bruges i trusted applications. Access tokens er typisk short-lived mens refresh tokens er longer-lived og bruges til at få nye access tokens. Scopes definerer permissions som client requester - for eksempel read:user eller write:posts. State parameter beskytter mod CSRF attacks. OAuth 2.0 specificerer ikke token format men JWT er almindeligt brugt. OpenID Connect bygger på OAuth 2.0 og tilføjer authentication layer med ID tokens.",
    "source": "RFC 6749 - The OAuth 2.0 Authorization Framework, IETF"
  },
  {
    "title": "Redis Caching Strategies",
    "content": "Redis er en in-memory data structure store brugt som database, cache og message broker. Som cache reducerer Redis load på primær database ved at gemme frequently accessed data i hukommelsen. Data structures i Redis inkluderer strings, hashes, lists, sets, sorted sets, bitmaps og HyperLogLogs. Cache-aside pattern er mest common: application checker Redis først, ved cache miss hentes data fra database og gemmes i Redis. Write-through cache opdaterer både cache og database samtidigt hvilket sikrer consistency. Write-behind cache opdaterer kun cache først og synkroniserer til database asynkront hvilket giver bedre write performance men risikerer data loss. Keys bør navngives konsistent med patterns som user:1234:profile. Expiration kan sættes med EXPIRE kommando for automatisk at rydde gamle data. Eviction policies som LRU (Least Recently Used) styrer hvad der slettes når memory er fyldt. Redis persistence options inkluderer RDB snapshots og AOF (Append Only File) logging. Redis Cluster giver horizontal scaling ved at distribuere data across multiple nodes. Pub/Sub messaging lader services subscribe til channels for real-time events. Redis Streams understøtter consumer groups for distributed processing. Transaction support med MULTI og EXEC sikrer atomic operations.",
    "source": "Redis Documentation 7.0, Redis University"
  }
]
